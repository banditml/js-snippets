window.banditml=window.banditml||{},banditml.BanditAPI=function(t,e={},i={}){this.storage=window.localStorage,this.banditApikey=t,this.sessionIdKey="BanditMLSessionId",this.lastActionTimeKey="BanditMLLastActionTime",this.recClassByExperimentId=e,this.decisionsLoggedById={};this.config=Object.assign({debugMode:!1,sessionLengthHrs:.5,banditHostUrl:"https://www.banditml.com/api/",getSessionId:null},i),this.banditDecisionEndpoint=`${this.config.banditHostUrl}decision`,this.banditLogRewardEndpoint=`${this.config.banditHostUrl}reward`,this.banditLogDecisionEndpoint=`${this.config.banditHostUrl}log_decision`,this.banditValidationEndpoint=`${this.config.banditHostUrl}validate`,this.ipUrl="https://api.ipify.org?format=json"},banditml.BanditAPI.prototype.addDecisionHandler=function(t,e,i){const n=this,s=n.recClassByExperimentId[i],o=document.getElementsByClassName(s)[0];o&&document.addEventListener("scroll",function(){!n.decisionsLoggedById[e.id]&&o.getBoundingClientRect().bottom<=window.innerHeight&&(n.config.debugMode&&console.log("User has seen decision. Auto logging it."),n.logDecision(t,e,i),n.decisionsLoggedById[e.id]=!0)})},banditml.BanditAPI.prototype.lastDecisionKey=function(t){return`BanditMLLastDecision-${t}`},banditml.BanditAPI.prototype.isTimeExpired=function(t,e){return((new Date).getTime()-t)/36e5>e},banditml.BanditAPI.prototype.uuidv4=function(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,t=>(t^crypto.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16))},banditml.BanditAPI.prototype.getLastDecision=function(t){return this.getItemFromStorage(this.lastDecisionKey(t))},banditml.BanditAPI.prototype.updateLastDecision=function(t,e){this.setItemInStorage(this.lastDecisionKey(e),t)},banditml.BanditAPI.prototype.updateSessionId=function(){let t=this.getItemFromStorage(this.sessionIdKey),e=this.getItemFromStorage(this.lastActionTimeKey);return t&&e&&!this.isTimeExpired(e,this.config.sessionLengthHrs)||(t=this.uuidv4(),this.setItemInStorage(this.sessionIdKey,t),this.setItemInStorage(this.lastActionTimeKey,(new Date).getTime())),t},banditml.BanditAPI.prototype.clearSession=function(){this.storage.removeItem(this.sessionIdKey),this.storage.removeItem(this.lastActionTimeKey)},banditml.BanditAPI.prototype.getSessionId=function(){let t,e="";return this.config.getSessionId?(t=this.config.getSessionId(),e="Looks like you are using your own getSessionId function. Double check this isn't returning null."):t=this.getItemFromStorage(this.sessionIdKey)||this.updateSessionId(),this.assert(t&&"string"==typeof t,`sessionId needs to be non-null string, somehow it's ${t} instead.`+e),t},banditml.BanditAPI.prototype.assert=function(t,e){if(!t){if(e=e||"Assertion failed.",e+=" Contact support@banditml.com for assistance.","undefined"!=typeof Error)throw new Error(e);throw e}},banditml.BanditAPI.prototype.isFunction=function(t){if(!t)return!1;const e={}.toString.call(t);return"[object Function]"===e||"[object AsyncFunction]"===e},banditml.BanditAPI.prototype.asyncGetRequest=async function(t,e={},i={}){e&&Object.keys(e).length&&(t+="?");for(const i in e){let n=e[i];if(null!=i&&null!=n){const e=typeof n;let s;t+=`${i}=${s="number"===e||"string"===e?n:encodeURIComponent(JSON.stringify(n))}&`}}const n=await fetch(t,{method:"GET",headers:i});return await n.json()},banditml.BanditAPI.prototype.asyncPostRequest=async function(t="",e={},i={}){e.hasOwnProperty("Content-Type")||(e["Content-Type"]="application/json");const n=await fetch(t,{method:"POST",headers:e,body:JSON.stringify(i)});return await n.json()},banditml.BanditAPI.prototype.getItemFromStorage=function(t){return JSON.parse(this.storage.getItem(t))},banditml.BanditAPI.prototype.contextName=function(t){return`banditMLContext-${t}`},banditml.BanditAPI.prototype.contextValidationKey=function(t){return`banditMLContextValidation-${t}`},banditml.BanditAPI.prototype.getContext=function(t){return this.getItemFromStorage(this.contextName(t))||{}},banditml.BanditAPI.prototype.validateAndFilterFeaturesInContext=function(t,e){const i=this;let n={};for(const s in t){if("ipAddress"===s){n.ipAddress=t.ipAddress;continue}if(e.hasOwnProperty(s)){const o=t[s],a=e[s],r=a.possible_values,d=a.type;try{if("N"===d){const t=typeof o;i.assert("number"==typeof o,`Feature ${s} is expected to be numeric, but ${o} of type ${t} was passed.`)}else"C"===d?(i.assert(Array.isArray(r),`Feature ${s} is categorical, but its possible values is not an array. Update the model appropriately in Bandit ML.`),i.assert(r.includes(t[s]),`Value ${o} is not recognized among possible values for feature ${s}. Please update the possible values in Bandit ML.`)):"P"===d&&(i.assert(Array.isArray(r),`Feature ${s} is a product set, but its possible values is not an array. Update the model appropriately in Bandit ML.`),i.assert("string"==typeof o||Array.isArray(o),`Feature ${s} is a product set that expects an array or string, but ${o} is not an array or string.`),Array.isArray(o)?i.assert(o.every(t=>r.includes(t)),`${o} is not included in ${s}'s possible values ${r}.`):i.assert(r.includes(o),`${o} is not included in ${s}'s possible values ${r}.`));n[s]=o}catch(t){console.error(t),console.error(`Not including ${s} in context due to invalid/unrecognized value.`)}}else console.warn(`Feature ${s} is not recognized by the model. Please update your model to include this feature.`)}return n},banditml.BanditAPI.prototype.validateAndFilterContext=function(t,e){const i=this;i.assert("object"==typeof t&&null!==t,"Context must be a non-null object.");let n=i.getItemFromStorage(i.contextValidationKey(e));if(!n||i.isTimeExpired(n.generated_at_ms,4)){return i.asyncGetRequest(url=i.banditValidationEndpoint,params={experimentId:e},headers={Authorization:`ApiKey ${i.banditApikey}`}).then(s=>(n=s,i.setItemInStorage(i.contextValidationKey(e),n),i.validateAndFilterFeaturesInContext(t,n)))}return i.validateAndFilterFeaturesInContext(t,n)},banditml.BanditAPI.prototype.setItemInStorage=function(t,e){this.storage.setItem(t,JSON.stringify(e))},banditml.BanditAPI.prototype.setContext=async function(t,e){try{let i=this.validateAndFilterContext(t,e);return i.then&&(i=await i),this.setItemInStorage(this.contextName(e),i),i||{}}catch(t){return console.error(t),i||{}}},banditml.BanditAPI.prototype.clearContext=function(t){this.storage.removeItem(this.contextName(t))},banditml.BanditAPI.prototype.updateContext=async function(t,e){this.assert("object"==typeof t&&null!==t,"newContext must be a non-null object."),this.assert(e&&"string"==typeof e,`experimentId must be non-null string. Got ${e} instead`);let i=this.getContext(e);return i=null==i?t:Object.assign({},i,t),(i=this.setContext(i,e)).then&&(i=await i),this.updateSessionId(),this.config.debugMode&&(console.log("Updated context."),console.log(i)),i},banditml.BanditAPI.prototype.getControlRecs=async function(t){let e;if(this.assert(Array.isArray(t)||this.isFunction(t),"defaultDecisionIds must be an array or function."),Array.isArray(t))e=t;else{let i=t();e=i&&i.then?await i:i}return e},banditml.BanditAPI.prototype.setRecs=async function(t=null,e=null,i=null){const n=this;if(t.then&&(t=await t),n.validateDecisionIds(t),e){n.assert(n.isFunction(e),"filterRecs must be a function.");let i=e(t);i&&(t=i.then?await i:i)}if(n.config.debugMode&&(console.log("After filtering, the following recs will be shown:"),console.log(t)),i){n.assert(n.isFunction(i),"populateDecisions must be a function.");let e=i(t);e&&(t=e.then?await e:e)}return t},banditml.BanditAPI.prototype.getDecision=async function(t,e=null,i=null,n=null,s=!0){const o=this;function a(t){return console.error("Error getting decision, setting your default recs instead."),console.error(t),o.setRecs(o.getControlRecs(e),i,n)}null!==t&&o.assert(null!==t&&"string"==typeof t,"experimentId needs to be non-null string.");let r=o.getContext(t);if(!("ipAddress"in r))try{let e=o.asyncGetRequest(o.ipUrl,params={},headers={"Content-Type":"application/json",Accept:"application/json"});const i=(await e).ip;r.ipAddress=i,(r=o.updateContext(r,t)).then&&(r=await r)}catch(t){return a(t)}return o.asyncGetRequest(url=o.banditDecisionEndpoint,params={context:r,experimentId:t},headers={Authorization:`ApiKey ${o.banditApikey}`}).then(async a=>{let d,l=a,c=l.decision.ids.reduce((t,e,i)=>(t[e]=l.decision.scores[i],t),{});if(o.config.debugMode&&(console.log("Got a decision from Bandit."),console.log(l)),"D"===l.decision.type){const t=l.decision.ids;d=e&&a.decision.isControl?await o.getControlRecs(e):t,d=await o.setRecs(d,i,n),l.decision.ids=d}else d=l.decision.ids,await o.setRecs(d,i,n);return l.decision.scores=l.decision.ids.map(t=>c[t]),s&&(o.config.debugMode&&(console.log("Will log decision when user sees it"),console.log(l)),o.addDecisionHandler(r,l,t)),a}).catch(t=>a(t))},banditml.BanditAPI.prototype.validateDecisionIds=function(t){const e=typeof t;this.assert(Array.isArray(t)||"number"===e||"string"===e,"decision IDs must be an array, number, or string")},banditml.BanditAPI.prototype.logDecision=function(t,e,i){const n=e.decision;this.validateDecisionIds(n.ids);const s={Authorization:`ApiKey ${this.banditApikey}`};this.asyncPostRequest(this.banditLogDecisionEndpoint,s,{id:e.id,context:t,decision:n,experimentId:i,mdpId:this.getSessionId(),variantId:n.variantId}).then(t=>(this.config.debugMode&&(console.log("Successfully logged decision"),console.log(t)),this.updateLastDecision(n,i),t)).catch(t=>{console.error(t)})},banditml.BanditAPI.prototype.isDelayedReward=function(t,e){let i=this.getItemFromStorage(this.contextValidationKey(e));return this.assert(i,"contextValidation is null, possibly from calling logReward without updating context."),Object.keys(t).every(t=>i.choices.possible_values.includes(t))},banditml.BanditAPI.prototype.logReward=function(t,e,i=null,n=null){const s={Authorization:`ApiKey ${this.banditApikey}`};this.assert(t&&"object"==typeof t,"Reward needs to be a non-empty object."),this.isDelayedReward(t,e)?(this.assert(null===i,"decision needs to be null for delayed rewards."),this.assert(null===n,"decisionId needs to be null for delayed rewards.")):(this.assert(i&&"string"==typeof i,`For immediate rewards, decision needs to be a single string ID. Got ${i} instead.`),this.assert(n&&"string"==typeof n,`For immediate rewards, decisionId needs to be a single string ID. Got ${n} instead.`)),this.asyncPostRequest(this.banditLogRewardEndpoint,s,{decisionId:n,decision:i,metrics:t,experimentId:e,mdpId:this.getSessionId()}).then(t=>(this.config.debugMode&&(console.log("Successfully logged reward."),console.log(t)),null===n&&this.clearSession(),t)).catch(t=>{console.error(t)})},window.BanditAPI=window.banditml.BanditAPI;