window.banditml=window.banditml||{},banditml.BanditAPI=function(t,e={},n={}){this.storage=window.localStorage,this.banditApikey=t,this.sessionIdKey="BanditMLSessionId",this.lastActionTimeKey="BanditMLLastActionTime",this.recClassByExperimentId=e,this.decisionsLoggedById={};this.config=Object.assign({debugMode:!1,sessionLengthHrs:.5,banditHostUrl:"https://www.banditml.com/api/",getSessionId:null},n),this.banditDecisionEndpoint=`${this.config.banditHostUrl}decision`,this.banditLogRewardEndpoint=`${this.config.banditHostUrl}reward`,this.banditLogDecisionEndpoint=`${this.config.banditHostUrl}log_decision`,this.banditValidationEndpoint=`${this.config.banditHostUrl}validate`,this.ipUrl="https://api.ipify.org?format=json"},banditml.BanditAPI.prototype.addDecisionHandler=function(t,e,n){const i=this,o=i.recClassByExperimentId[n],s=document.getElementsByClassName(o)[0];s&&document.addEventListener("scroll",function(){!i.decisionsLoggedById[e.id]&&s.getBoundingClientRect().bottom<=window.innerHeight&&(i.config.debugMode&&console.log("User has seen decision. Auto logging it."),i.logDecision(t,e,n),i.decisionsLoggedById[e.id]=!0)})},banditml.BanditAPI.prototype.lastDecisionKey=function(t){return`BanditMLLastDecision-${t}`},banditml.BanditAPI.prototype.isTimeExpired=function(t,e){return((new Date).getTime()-t)/36e5>e},banditml.BanditAPI.prototype.uuidv4=function(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,t=>(t^crypto.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16))},banditml.BanditAPI.prototype.getLastDecision=function(t){return this.getItemFromStorage(this.lastDecisionKey(t))},banditml.BanditAPI.prototype.updateLastDecision=function(t,e){this.setItemInStorage(this.lastDecisionKey(e),t)},banditml.BanditAPI.prototype.updateSessionId=function(){let t=this.getItemFromStorage(this.sessionIdKey),e=this.getItemFromStorage(this.lastActionTimeKey);return t&&e&&!this.isTimeExpired(e,this.config.sessionLengthHrs)||(t=this.uuidv4(),this.setItemInStorage(this.sessionIdKey,t),this.setItemInStorage(this.lastActionTimeKey,(new Date).getTime())),t},banditml.BanditAPI.prototype.clearSession=function(){this.storage.removeItem(this.sessionIdKey),this.storage.removeItem(this.lastActionTimeKey)},banditml.BanditAPI.prototype.getSessionId=function(){let t,e="";return this.config.getSessionId?(t=this.config.getSessionId(),e="Looks like you are using your own getSessionId function. Double check this isn't returning null."):t=this.getItemFromStorage(this.sessionIdKey)||this.updateSessionId(),this.assert(t&&"string"==typeof t,`sessionId needs to be non-null string, somehow it's ${t} instead.`+e),t},banditml.BanditAPI.prototype.assert=function(t,e){if(!t){if(e=e||"Assertion failed.",e+=" Contact support@banditml.com for assistance.","undefined"!=typeof Error)throw new Error(e);throw e}},banditml.BanditAPI.prototype.isFunction=function(t){if(!t)return!1;const e={}.toString.call(t);return"[object Function]"===e||"[object AsyncFunction]"===e},banditml.BanditAPI.prototype.asyncGetRequest=async function(t,e={},n={}){e&&Object.keys(e).length&&(t+="?");for(const n in e){let i=e[n];if(null!=n&&null!=i){const e=typeof i;let o;t+=`${n}=${o="number"===e||"string"===e?i:encodeURIComponent(JSON.stringify(i))}&`}}const i=await fetch(t,{method:"GET",headers:n});return await i.json()},banditml.BanditAPI.prototype.asyncPostRequest=async function(t="",e={},n={}){e.hasOwnProperty("Content-Type")||(e["Content-Type"]="application/json");const i=await fetch(t,{method:"POST",headers:e,body:JSON.stringify(n)});return await i.json()},banditml.BanditAPI.prototype.getItemFromStorage=function(t){return JSON.parse(this.storage.getItem(t))},banditml.BanditAPI.prototype.contextName=function(t){return`banditMLContext-${t}`},banditml.BanditAPI.prototype.contextValidationKey=function(t){return`banditMLContextValidation-${t}`},banditml.BanditAPI.prototype.serverSideCacheKey=function(t){return`banditMLServerSideCache-${t}`},banditml.BanditAPI.prototype.getContext=function(t){return this.getItemFromStorage(this.contextName(t))||{}},banditml.BanditAPI.prototype.validateAndFilterFeaturesInContext=function(t,e){const n=this;let i={};for(const o in t){if("ipAddress"===o){i.ipAddress=t.ipAddress;continue}if(e.hasOwnProperty(o)){const s=t[o],a=e[o],r=a.possible_values,d=a.type;try{if(null==s)console.warn(`Not including ${o} in context due to null value.`);else if("N"===d){const t=typeof s;n.assert("number"==typeof s,`Feature ${o} is expected to be numeric, but ${s} of type ${t} was passed.`)}else"C"===d?(n.assert(Array.isArray(r),`Feature ${o} is categorical, but its possible values is not an array. Update the model appropriately in Bandit ML.`),n.assert(r.includes(t[o]),`Value ${s} is not recognized among possible values for feature ${o}. Please update the possible values in Bandit ML.`)):"P"===d&&(n.assert(Array.isArray(r),`Feature ${o} is a product set, but its possible values is not an array. Update the model appropriately in Bandit ML.`),n.assert("string"==typeof s||Array.isArray(s),`Feature ${o} is a product set that expects an array or string, but ${s} is not an array or string.`),Array.isArray(s)?n.assert(s.every(t=>r.includes(t)),`${s} is not included in ${o}'s possible values ${r}.`):n.assert(r.includes(s),`${s} is not included in ${o}'s possible values ${r}.`));i[o]=s}catch(t){console.error(t),console.error(`Not including ${o} in context due to invalid/unrecognized value.`)}}else console.warn(`Feature ${o} is not recognized by the model. Please update your model to include this feature.`)}return i},banditml.BanditAPI.prototype.validateAndFilterContext=function(t,e){const n=this;n.assert("object"==typeof t&&null!==t,"Context must be a non-null object.");let i=n.getItemFromStorage(n.contextValidationKey(e));if(!i||n.isTimeExpired(i.generated_at_ms,4)){return n.asyncGetRequest(url=n.banditValidationEndpoint,params={experimentId:e},headers={Authorization:`ApiKey ${n.banditApikey}`}).then(o=>(i=o,n.setItemInStorage(n.contextValidationKey(e),i),n.validateAndFilterFeaturesInContext(t,i)))}return n.validateAndFilterFeaturesInContext(t,i)},banditml.BanditAPI.prototype.setItemInStorage=function(t,e){this.storage.setItem(t,JSON.stringify(e))},banditml.BanditAPI.prototype.setContext=async function(t,e){try{let n=this.validateAndFilterContext(t,e);return n.then&&(n=await n),this.setItemInStorage(this.contextName(e),n),n||{}}catch(t){return console.error(t),n||{}}},banditml.BanditAPI.prototype.clearContext=function(t){this.storage.removeItem(this.contextName(t))},banditml.BanditAPI.prototype.updateContext=async function(t,e){this.assert("object"==typeof t&&null!==t,"newContext must be a non-null object."),this.assert(e&&"string"==typeof e,`experimentId must be non-null string. Got ${e} instead`);let n=this.getContext(e);return n=null==n?t:Object.assign({},n,t),(n=this.setContext(n,e)).then&&(n=await n),this.updateSessionId(),this.config.debugMode&&(console.log("Updated context."),console.log(n)),n},banditml.BanditAPI.prototype.getControlRecs=async function(t){let e;if(this.assert(Array.isArray(t)||this.isFunction(t),"defaultDecisionIds must be an array or function."),Array.isArray(t))e=t;else{let n=t();e=n&&n.then?await n:n}return e},banditml.BanditAPI.prototype.setRecs=async function(t=null,e=null,n=null){const i=this;if(t.then&&(t=await t),i.validateDecisionIds(t),e){i.assert(i.isFunction(e),"filterRecs must be a function.");let n=e(t);n&&(t=n.then?await n:n)}if(i.config.debugMode&&(console.log("After filtering, the following recs will be shown:"),console.log(t)),n){i.assert(i.isFunction(n),"populateDecisions must be a function.");let e=n(t);e&&(t=e.then?await e:e)}return t},banditml.BanditAPI.prototype.getDecision=async function(t,e=null,n=null,i=null,o=!0){const s=this;function a(t){return console.error("Error getting decision, setting your default recs instead."),console.error(t),s.setRecs(s.getControlRecs(e),n,i)}null!==t&&s.assert(null!==t&&"string"==typeof t,"experimentId needs to be non-null string.");let r=s.getContext(t);if(!("ipAddress"in r))try{let e=s.asyncGetRequest(s.ipUrl,params={},headers={"Content-Type":"application/json",Accept:"application/json"});const n=(await e).ip;r.ipAddress=n,(r=s.updateContext(r,t)).then&&(r=await r)}catch(t){return a(t)}let d=s.getItemFromStorage(s.serverSideCacheKey(t));return s.asyncGetRequest(url=s.banditDecisionEndpoint,params={context:r,experimentId:t,cache:d},headers={Authorization:`ApiKey ${s.banditApikey}`}).then(async a=>{let d=a,l=d.decision.cache;null!=l?s.setItemInStorage(s.serverSideCacheKey(t),l):s.config.debugMode&&console.log("Null cache passed back from Bandit ML server.");let c,u=d.decision.ids.reduce((t,e,n)=>(t[e]=d.decision.scores[n],t),{});if(s.config.debugMode&&(console.log("Got a decision from Bandit."),console.log(d)),"D"===d.decision.type){const t=d.decision.ids;c=e&&a.decision.isControl?await s.getControlRecs(e):t,c=await s.setRecs(c,n,i),d.decision.ids=c}else c=d.decision.ids,await s.setRecs(c,n,i);return d.decision.scores=d.decision.ids.map(t=>u[t]),o&&(s.config.debugMode&&(console.log("Will log decision when user sees it"),console.log(d)),s.addDecisionHandler(r,d,t)),a}).catch(t=>a(t))},banditml.BanditAPI.prototype.validateDecisionIds=function(t){const e=typeof t;this.assert(Array.isArray(t)||"number"===e||"string"===e,"decision IDs must be an array, number, or string")},banditml.BanditAPI.prototype.logDecision=function(t,e,n){const i=e.decision;this.validateDecisionIds(i.ids);const o={Authorization:`ApiKey ${this.banditApikey}`};this.asyncPostRequest(this.banditLogDecisionEndpoint,o,{id:e.id,context:t,decision:i,experimentId:n,mdpId:this.getSessionId(),variantId:i.variantId}).then(t=>(this.config.debugMode&&(console.log("Successfully logged decision"),console.log(t)),this.updateLastDecision(i,n),t)).catch(t=>{console.error(t)})},banditml.BanditAPI.prototype.isDelayedReward=function(t,e){let n=this.getItemFromStorage(this.contextValidationKey(e));return this.assert(n,"contextValidation is null, possibly from calling logReward without updating context."),Object.keys(t).every(t=>n.choices.possible_values.includes(t))},banditml.BanditAPI.prototype.logReward=function(t,e,n=null,i=null){const o={Authorization:`ApiKey ${this.banditApikey}`};this.assert(t&&"object"==typeof t,"Reward needs to be a non-empty object."),this.isDelayedReward(t,e)?(this.assert(null===n,"decision needs to be null for delayed rewards."),this.assert(null===i,"decisionId needs to be null for delayed rewards.")):(this.assert(n&&"string"==typeof n,`For immediate rewards, decision needs to be a single string ID. Got ${n} instead.`),this.assert(i&&"string"==typeof i,`For immediate rewards, decisionId needs to be a single string ID. Got ${i} instead.`)),this.asyncPostRequest(this.banditLogRewardEndpoint,o,{decisionId:i,decision:n,metrics:t,experimentId:e,mdpId:this.getSessionId()}).then(t=>(this.config.debugMode&&(console.log("Successfully logged reward."),console.log(t)),null===i&&this.clearSession(),t)).catch(t=>{console.error(t)})},window.BanditAPI=window.banditml.BanditAPI;
